# MVCC 的实现逻辑

# 事务相关讨论

## 事务的启动时机

begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。

## 事务隔离下的读写

可重复读隔离级别下会引申出一个“矛盾”：一方面事务是可重复读，即整个事务期间都看到的是事务刚刚启动时候的视图；但是又因为行锁，事务在执行过程中可能需要等待别的事务更新同一行，那这时候如果该事务也要更新，看到的还是事务刚刚创建时事务的状态吗？ 
显然不是，这里的关键就是对于更新操作来说，需要当前读。
可重复读隔离级别，会建立数据的视图
MySQL中读取数据的时候总是一致性读：事务开始前会创建一个一致性视图，在事务执行过程中，所有其他未提交或者已经提交的事务，对当前已经开启的事务不可见。 但是在更新数据的时候，会执行当前读：意思是在更新之前会去数据库中获取最新的已经提交的事务数据内容，然后基于已经提交的事务的基础上更新自己的内容。也就是一个事务在开启后，执行读和执行写对应的数据是不一样的，所有的执行读都是读取事务开启时所创建的一致性视图，而执行更新操作则不是更新这个一致性视图，而是会执行当前读（即重新读取数据库最新的数据），在数据库最新的数据上进行更新。
在 MySQL 里，有两个“视图”的概念：

> * 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
> * 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。

